# Customize this file, documentation can be found here:
# https://docs.fastlane.tools/actions/
# All available actions: https://docs.fastlane.tools/actions
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version "2.89.0"

fastlane_require "open-uri" 
fastlane_require 'net/http'
fastlane_require 'json'

default_platform :ios

before_all do 
    # æŠŠç¼–è¯‘è¶…æ—¶æ—¶é—´è®¾ç½®é•¿ä¸€äº›ï¼Œä»¥é˜²å› è¶…æ—¶å¯¼è‡´ç¼–è¯‘å¤±è´¥
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "120"
    #è®¾ç½®ITCä¸Šä¼ æ–¹å¼
    ENV["DELIVER_ITMSTRANSPORTER_ADDITIONAL_UPLOAD_PARAMETERS"] = "-t DAV"
    ENV["FASTLANE_ITUNES_TRANSPORTER_USE_SHELL_SCRIPT"] = "1"
 end


  desc "perform a task, æŽ¥å—å‚æ•°type,å€¼å¯ä¸ºappstore, adhoc, development, enterprise;å‚æ•°"
  lane :task do |options|
    # èŽ·å¾—é€‰é¡¹ï¼Œå¯ä»¥æ˜¯appstore, adhoc, enterprise, development
    type = options[:type]
    # æ˜¯å¦åº”è¯¥ä¸Šä¼ 
    shouldUpload = options[:upload]
    if shouldUpload.nil?
      shouldUpload = true
    end
    
    bundle_id = ENV['APP_IDENTIFIER'] 
    scheme = ENV['APP_SCHEME']

    #åŒæ­¥è¯ä¹¦
    sync_code_signing(type: type,readonly: true)

    # èŽ·å– export_method
    export_method = get_export_method(type:type)
    # ç”ŸæˆIPAåŒ…åç§°
    output_name = gen_ipa_output_name(type:type)
    # èŽ·å–æè¿°æ–‡ä»¶åç§°
    provisioning = get_provisioning_name(type:type)
    # èŽ·å–ç¼–è¯‘é…ç½®åç§°
    configuration = get_build_configuration(type:type)

    # å¢žåŠ ç‰ˆæœ¬å· æˆ–è€… build å·
    increment_versionNumber_or_buildNumber(type:type);

    # cocoapods
    cocoapods

    # ä¿®æ”¹è¯ä¹¦ç­¾åé…ç½®
    cosigner(
        scheme: ENV['APP_SCHEME'],
        xcodeproj_path: ENV['PROJECT_PATH'],
        build_configuration: configuration,
        profile_name: ENV['sigh_' + bundle_id + '_' + type + '_profile-name']
    )

    # ç¼–è¯‘
    build_ios_app(output_name: output_name,
        silent: false,
        clean: true,
        export_method: export_method,
        export_xcargs: "-allowProvisioningUpdates",
        configuration: configuration,
        export_options: {
                  provisioningProfiles: { 
                    bundle_id => provisioning
                  }
                })

    #å¦‚æžœä¸ºfalseåˆ™è·³è¿‡å‘å¸ƒä¸Šä¼ 
    if shouldUpload == false
      next
    end

    # deliver
    output_directory = ENV["IPA_OUT_DIR"]
    if type == "appstore"
      # default
      ENV["DELIVER_ITMSTRANSPORTER_ADDITIONAL_UPLOAD_PARAMETERS"] = "-t DAV"
      upload_to_app_store
    end

    if type == "adhoc"
      #ä¸Šä¼ åˆ°è’²å…¬è‹±
      pgyer
      #èŽ·å¾—Appç›¸å…³ä¿¡æ¯
      page_url = lane_context[SharedValues::PGYER_PAGE_URL]
      appName =  lane_context[SharedValues::PGYER_APP_NAME]
      version = lane_context[SharedValues::PGYER_APP_VERSION]
      buildNumber = lane_context[SharedValues::PGYER_APP_BUILD]
      # #å‘é€é’‰é’‰æ¶ˆæ¯
      notify_app_release(appName: appName,
                         versionNumber: version,
                         buildNumber: buildNumber,
                         appUrl: page_url)

    end

    if type == "development"
      puts "æ•¬è¯·æœŸå¾…..."
    end

    if type == "enterprise"
      puts "æ•¬è¯·æœŸå¾…..."
    end

  end

  desc "get_export_method,  æŽ¥å—å‚æ•°type,å€¼å¯ä»¥æ˜¯: appstore, adhoc, development æˆ– enterprise"
  lane :get_export_method do |options|
    type = options[:type]
    list = {
      "appstore" => "app-store",
      "adhoc" => "ad-hoc",
      "enterprise" => "enterprise",
      "development" => "development"
    }
    list[type]
  end

  desc "gen_ipa_output_name, æŽ¥å—å‚æ•°type,å€¼å¯ä»¥æ˜¯: appstore, adhoc, development æˆ– enterprise"
  lane :gen_ipa_output_name do |options|
    type = options[:type]
    scheme = ENV['APP_SCHEME']
    now = Time.now.strftime("%Y-%m-%d_%H-%M-%S")
    output_name = "#{scheme}_#{now}_#{type}.ipa"
  end

  desc "get_provisioning_name, æŽ¥å—å‚æ•°type,å€¼å¯ä»¥æ˜¯: appstore, adhoc, development æˆ– enterprise"
  lane :get_provisioning_name do |options|
    type = options[:type]
    bundle_id = ENV["APP_IDENTIFIER"]
    list = {
      "appstore" => "AppStore",
      "adhoc" => "AdHoc",
      "development" => "Development",
      "enterprise" => "InHouse"
    }
    provisioning_name = "match #{list[type]} #{bundle_id}"
  end

  desc "get_build_configuration, æŽ¥å—å‚æ•°type,å€¼å¯ä»¥æ˜¯: appstore, adhoc, development æˆ– enterprise"
  lane :get_build_configuration do |options|
    type = options[:type]
    list = {
      "appstore" => "Release",
      "adhoc" => "Ad Hoc",
      "development" => "Debug",
      "enterprise" => "Enterprise"
    }
    list[type]
  end

  desc "is app existing in appstore?, params: bundle_id"
  lane :is_app_in_appstore do |options|
    bundle_id = options[:bundle_id]
    now = Time.now.strftime("%Y%m%d%H%M%S")
    uri = URI("https://itunes.apple.com/lookup?bundleId=#{bundle_id}&country=cn&fetchTime=#{now}")
    Net::HTTP.get(uri)
    response = Net::HTTP.get_response(uri)
    puts "uri:#{uri},body:#{response.body}"
    UI.crash!("Action:is_app_in_appstore error:Unexpected status code from iTunes Search API") unless response.kind_of?(Net::HTTPSuccess)
    response.body.length > 50
  end


  desc "increment_versionNumber_or_buildNumber, æŽ¥å—å‚æ•°type,å€¼å¯ä¸ºappstore, adhoc, development, enterprise"
  lane :increment_versionNumber_or_buildNumber do |options|
    type = options[:type]
    scheme = ENV['APP_SCHEME']
    bundle_id = ENV['APP_IDENTIFIER']

    appstoreVersion = get_app_version_in_appstore(bundle_id: bundle_id)
    plistVersion = get_version_number_from_plist(scheme: scheme)
          #å¦‚æžœappstore ç‰ˆæœ¬å’Œ info.plistä¸­çš„ç‰ˆæœ¬ä¸€è‡´ åˆ™éœ€è¦å¢žåŠ ç‰ˆæœ¬å· å¦åˆ™è¯´æ˜Žå·²ç»å¢žåŠ è¿‡ç‰ˆæœ¬å·ï¼Œåªéœ€å¢žåŠ buildå°±è¡Œ
    if appstoreVersion == plistVersion
        puts "appstoreVersion:#{appstoreVersion},plistVersion#{plistVersion}"
        increment_version_number_in_plist(
          scheme: scheme
        )
        # å¦‚æžœç‰ˆæœ¬å·å¢žåŠ äº†ï¼Œé‚£ä¹ˆé‡ç½®build number ä¸º 1
        increment_build_number_in_plist(
          scheme: scheme,
          build_number: "1" # set build number to 1
        )
    else
      increment_build_number_in_plist(
          scheme: scheme
        ) 
    end
  end

  desc "å‘é€æ¶ˆæ¯åˆ°é’‰é’‰"
  lane :send_message_to_dingtalk do |options|
    msg = options[:message]
    token = ENV['DINGTALK_TOKEN']
    atMobile = ENV['DINGTALK_AT_MOBILE']
    url = "https://oapi.dingtalk.com/robot/send?access_token=#{token}"
    toSend = {  msgtype: "text", 
                text: {
                    content: msg
                }, 
                at: {
                    atMobiles: [
                        atMobile
                    ],
                    isAtAll: false
                }
             }
    uri = URI.parse(url)
    https = Net::HTTP.new(uri.host, uri.port)
    https.use_ssl = true

    req = Net::HTTP::Post.new(uri.request_uri)
    req.add_field('Content-Type', 'application/json')
    req.body = toSend.to_json
    res = https.request(req)
    puts "------------------------------"
    puts "Response #{res.code} #{res.message}: #{res.body}"
  end

  desc "é’‰é’‰æœºå™¨äººå‘é€æ¶ˆæ¯é€šçŸ¥appæµ‹è¯•ç‰ˆå·²ç»å‘å¸ƒ"
  lane :notify_app_release do |options|
    token = ENV['DINGTALK_TOKEN']
    appName = options[:appName]
    versionNumber = options[:versionNumber]
    buildNumber = options[:buildNumber]
    installUrl = options[:appUrl]
    url = "https://oapi.dingtalk.com/robot/send?access_token=#{token}"
    toSend = {
              msgtype: "actionCard",
              actionCard: {
                          title: "",
                          text: "### #{appName} #{versionNumber}(#{buildNumber})\n",
                          singleTitle: "æ‰«ç å®‰è£…ðŸ‘‰ðŸ‘‰",
                          singleURL: installUrl
                        }
              }
    uri = URI.parse(url)
    https = Net::HTTP.new(uri.host, uri.port)
    https.use_ssl = true
    req = Net::HTTP::Post.new(uri.request_uri)
    req.add_field('Content-Type', 'application/json')
    req.body = toSend.to_json
    res = https.request(req)
  end

  desc "Download metadata"
 lane :metadata do
    sh('bundle exec fastlane deliver download_metadata -m "$METADATA_PATH" -u $ITUNESCONNECT_USERNAME -a $BUNDLE_ID')
 end
 
  desc "Download metadata"
 lane :screenshots do
    sh('bundle exec fastlane deliver download_screenshots -w "$SCREENSHOTS_PATH" -u $ITUNESCONNECT_USERNAME -a $BUNDLE_ID')
 end

 desc "Only upload ipa to appstore"
 lane :only_upload_ipa do |options|
  ipa = options[:ipa]
  ENV["DELIVER_ITMSTRANSPORTER_ADDITIONAL_UPLOAD_PARAMETERS"] = "-t DAV"
  puts "ipa:#{ipa}"
  upload_to_app_store(ipa:ipa,
                      skip_screenshots: true,
                      skip_metadata: true)
 end


 desc "Only upload metadata to appstore"
 lane :only_upload_metadata do |options|
  path = options[:metadata_path]
  upload_to_app_store(metadata_path: path,
                      skip_screenshots: true,
                      skip_binary_upload: true)
 end

desc "sync enterprise signing"
 lane :sync_enterprise_signing do
  sync_code_signing(type:"enterprise")
 end

  desc "sync appstore signing"
 lane :sync_appstore_signing do
  sync_code_signing(type:"appstore")
 end

  desc "sync adhoc signing"
 lane :sync_adhoc_signing do
  sync_code_signing(type: "adhoc", force_for_new_devices: true)
 end

 desc "sync push signing"
 lane :sync_push_cert do
  app_identifier = ENV["APP_IDENTIFIER"]
  get_push_certificate(
  force: false, # create a new profile, even if the old one is still valid
  app_identifier: app_identifier, # optional app identifier,
  p12_password: "xdb201503",
  save_private_key: true,
  new_profile: proc do |profile_path| # this block gets called when a new profile was generated
    puts profile_path # the absolute path to the new PEM file
    # insert the code to upload the PEM file to the server
    end
  )
 end

  desc "Delete info plist value for key"
  lane :delete_info_plist_value do |options|
    info_plist_path = options[:path]
    key = options[:key]
    if !get_info_plist_value(path: info_plist_path,key: key).nil?
      Dir.chdir("..") do
        sh "/usr/libexec/PlistBuddy -c \"Delete :#{key}\" '#{info_plist_path}'"
      end
    end
  end

  desc "Read signing identity from .mobileprovision file"
  lane :mobileprovision_signing_identity do |options|
    provisionPath = options[:path]
    #å°†mobileprovisionæ–‡ä»¶è½¬ä¸ºplistæ ¼å¼
    output_plist_file = "/tmp/#{SecureRandom.uuid}.plist"
    sh("security cms -D -i '#{provisionPath}' -o '#{output_plist_file}'", log: true)      
    profile_plist = Plist.parse_xml(output_plist_file)
    #è¯»å–DeveloperCertificateså­—æ®µçš„å€¼
    cert_str = profile_plist['DeveloperCertificates'].first.string
    decoded_cert_file = "/tmp/#{SecureRandom.uuid}"
    File.write(decoded_cert_file, cert_str)
    #è½¬æ¢æ ¼å¼å¹¶æå– signing_identity
    signing_identity = sh("cat #{decoded_cert_file} | openssl x509 -noout -inform DER -subject | sed 's/^.*CN=\\([^\\/]*\\)\\/.*$/\\1/'", log:true)
    #åˆ é™¤ä¸´æ—¶æ–‡ä»¶
    sh("rm -rf #{output_plist_file} | rm -rf #{decoded_cert_file}")
    #åŽ»é™¤æœ«å°¾çš„æ¢è¡Œå›žè½¦ç¬¦
    $\ = "\r\n"
    signing_identity.chomp
  end


  desc "é‡ç­¾åæŒ‡å®šçš„ipa (ipa:è·¯å¾„,version:ç‰ˆæœ¬å·)"
  lane :resign_my_ipa do |options|
    ipaPath = options[:ipa]
    appVersion = options[:version]
    adhoc = options[:adhoc]
    if adhoc.nil?
      adhoc = false
    end

    #1.ä¸‹è½½æè¿°æ–‡ä»¶
    provisionFileName = "#{SecureRandom.uuid}.mobileprovision"
    provisionOutputDir = "/tmp"
    get_provisioning_profile(
      adhoc: adhoc,
      readonly: true,
      filename: provisionFileName,
      output_path: provisionOutputDir
    )
    profileFilePath = "#{provisionOutputDir}/#{provisionFileName}"

    #2.ä»Žmobileprovisionæ–‡ä»¶ä¸­æå– signing identitiy
    signingIdentity = mobileprovision_signing_identity(path: profileFilePath)

    #3.é‡ç­¾åipa
    if appVersion.nil?
      resign(
        ipa: ipaPath, # can omit if using the `ipa` action
        signing_identity: signingIdentity,
        provisioning_profile: profileFilePath, # can omit if using the _sigh_ action
      )
    else
      resign(
        ipa: ipaPath, # can omit if using the `ipa` action
        signing_identity: signingIdentity,
        provisioning_profile: profileFilePath, # can omit if using the _sigh_ action
        short_version: appVersion
      )
    end
    #4.åˆ é™¤mobileprovisionæ–‡ä»¶
    sh("rm -rf #{profileFilePath}")
  end

  desc "èŽ·å–APPåœ¨App Storeä¸Šçš„ç‰ˆæœ¬"
  lane :get_app_version_in_appstore do |options|
    bundle_id = options[:bundle_id]
    now = Time.now.strftime("%Y%m%d%H%M%S")
    uri = URI("https://itunes.apple.com/lookup?bundleId=#{bundle_id}&country=cn&fetchTime=#{now}")
    Net::HTTP.get(uri)
    response = Net::HTTP.get_response(uri)
    UI.crash!("Unexpected status code from iTunes Search API") unless response.kind_of?(Net::HTTPSuccess)
    response_body = JSON.parse(response.body)
    app_version = "0"
    if response_body["resultCount"] > 0
      app_version = response_body["results"][0]["version"]
    end
    puts "APP current AppStore version:#{app_version}"
    app_version
  end

  desc "Initialize for CI"
  lane :init_ci do |options|
    # sh "bundle update"
    setup_jenkins
    # install_plugins
  end
  
# More information about multiple platforms in fastlane: https://docs.fastlane.tools/advanced/#control-configuration-by-lane-and-by-platform
# All available actions: https://docs.fastlane.tools/actions

# fastlane reports which actions are used. No personal data is recorded.
# Learn more at https://docs.fastlane.tools/#metrics
